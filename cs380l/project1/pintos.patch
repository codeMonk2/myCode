diff -ruN '--exclude=build' aos_pintos/src/devices/timer.c pintos-solution/src/devices/timer.c
--- aos_pintos/src/devices/timer.c	2024-02-08 21:49:22.000000000 +0000
+++ pintos-solution/src/devices/timer.c	2024-02-28 15:05:59.021536790 +0000
@@ -3,6 +3,7 @@
 #include <inttypes.h>
 #include <round.h>
 #include <stdio.h>
+#include <list.h>
 #include "devices/pit.h"
 #include "threads/interrupt.h"
 #include "threads/synch.h"
@@ -24,6 +25,15 @@
    Initialized by timer_calibrate(). */
 static unsigned loops_per_tick;
 
+/* List of threads blocked on timer intervals */
+static struct list blocked_thds;
+static struct lock blocked_thds_lock;
+static struct thread *timerThread=NULL;
+
+void timer_thread(void *aux);
+bool time_comparator (const struct list_elem *e1,
+                      const struct list_elem *e2, void *aux);
+
 static intr_handler_func timer_interrupt;
 static bool too_many_loops (unsigned loops);
 static void busy_wait (int64_t loops);
@@ -34,6 +44,9 @@
    and registers the corresponding interrupt. */
 void timer_init (void)
 {
+  list_init(&blocked_thds);
+  lock_init(&blocked_thds_lock);
+  thread_create("timer", PRI_DEFAULT, timer_thread, NULL);
   pit_configure_channel (0, 2, TIMER_FREQ);
   intr_register_ext (0x20, timer_interrupt, "8254 Timer");
 }
@@ -78,15 +91,93 @@
    should be a value once returned by timer_ticks(). */
 int64_t timer_elapsed (int64_t then) { return timer_ticks () - then; }
 
+
+/* Begin - User defined func implementations */
+/* Wakes any blocked thread whose timer is completed */
+void timer_thread(void *aux UNUSED)
+{
+  enum intr_level old_level;
+  timerThread = thread_current();
+  while (true)
+  {
+    if (lock_try_acquire(&blocked_thds_lock))
+    {
+      if (list_empty(&blocked_thds))
+      {
+          lock_release(&blocked_thds_lock);
+          old_level = intr_disable();
+          thread_block();
+          intr_set_level(old_level);
+          continue;
+      }
+
+      struct list_elem *f = list_front(&blocked_thds);
+
+      if (list_entry(f, struct thread, timer_elem)->wakeup_tick <= timer_ticks())
+      {
+        struct thread *t = list_entry(f, struct thread, timer_elem);
+        list_pop_front(&blocked_thds);
+        lock_release(&blocked_thds_lock);
+        thread_unblock(t);
+      }
+      else
+      {
+        lock_release(&blocked_thds_lock);
+        old_level = intr_disable();
+        thread_block();
+        intr_set_level(old_level);
+        continue;
+      }
+    }
+  }
+
+  return;
+}
+
+// list ordered from smallest wakeup time to largest wakeup time
+bool
+time_comparator (const struct list_elem *e1,
+                 const struct list_elem *e2, void *aux UNUSED)
+{
+    struct thread* t1 = list_entry (e1, struct thread, timer_elem);
+    struct thread* t2 = list_entry (e2, struct thread, timer_elem);
+
+    if( t1->wakeup_tick < t2->wakeup_tick)
+        return true;
+    else if (t1->wakeup_tick == t2->wakeup_tick){
+        if( t1->priority > t2->priority)
+            return true;
+    }
+    return false;
+}
+
+/* End - User defined func implementations */
+
 /* Sleeps for approximately TICKS timer ticks.  Interrupts must
    be turned on. */
 void timer_sleep (int64_t ticks)
 {
-  int64_t start = timer_ticks ();
-
+  struct thread* cur = NULL;
+  enum intr_level old_level;
   ASSERT (intr_get_level () == INTR_ON);
-  while (timer_elapsed (start) < ticks)
-    thread_yield ();
+  if (ticks < 0)
+      return;
+
+  cur = thread_current();
+
+  cur->wakeup_tick = timer_ticks() + ticks;
+
+  while (true) {
+    if (lock_try_acquire(&blocked_thds_lock)) {
+      list_insert_ordered (&blocked_thds, &cur->timer_elem, time_comparator, NULL);
+      lock_release(&blocked_thds_lock);
+      break;
+    }
+  }
+
+  old_level = intr_disable();
+  thread_block();
+  intr_set_level(old_level);
 }
 
 /* Sleeps for approximately MS milliseconds.  Interrupts must be
@@ -139,6 +230,8 @@
 {
   ticks++;
   thread_tick ();
+  if (timerThread && timerThread->status == THREAD_BLOCKED)
+      thread_unblock(timerThread);
 }
 
 /* Returns true if LOOPS iterations waits for more than one timer
diff -ruN '--exclude=build' aos_pintos/src/threads/synch.c pintos-solution/src/threads/synch.c
--- aos_pintos/src/threads/synch.c	2024-02-08 21:49:22.000000000 +0000
+++ pintos-solution/src/threads/synch.c	2024-02-28 18:03:36.973036133 +0000
@@ -32,6 +32,8 @@
 #include "threads/interrupt.h"
 #include "threads/thread.h"
 
+bool sema_comparator(const struct list_elem *l1, const struct list_elem *l2,void *aux UNUSED);
+
 /* Initializes semaphore SEMA to VALUE.  A semaphore is a
    nonnegative integer along with two atomic operators for
    manipulating it:
@@ -66,7 +68,8 @@
   old_level = intr_disable ();
   while (sema->value == 0)
     {
-      list_push_back (&sema->waiters, &thread_current ()->elem);
+      list_insert_ordered (&sema->waiters, &thread_current ()->elem,
+                           priority_comparator, NULL);
       thread_block ();
     }
   sema->value--;
@@ -110,9 +113,13 @@
 
   old_level = intr_disable ();
   if (!list_empty (&sema->waiters))
+  {
+    list_sort(&sema->waiters, priority_comparator, NULL);
     thread_unblock (
         list_entry (list_pop_front (&sema->waiters), struct thread, elem));
+  }
   sema->value++;
+  thread_yield();
   intr_set_level (old_level);
 }
 
@@ -172,6 +179,7 @@
 
   lock->holder = NULL;
   sema_init (&lock->semaphore, 1);
+  lock->is_holder_running_with_inherited_prio = false;
 }
 
 /* Acquires LOCK, sleeping until it becomes available if
@@ -188,8 +196,34 @@
   ASSERT (!intr_context ());
   ASSERT (!lock_held_by_current_thread (lock));
 
+  if(lock->holder)
+  {
+    thread_current()->waiting_for = lock;
+    if(lock->holder->priority < thread_current()->priority)
+    {
+      /* Recursively go through the lock holders and inherit the priority */
+      struct thread *curT = thread_current();
+      while (curT->waiting_for)
+      {
+        struct lock *cur_lock = curT->waiting_for;
+        cur_lock->holder->inherited_priorities[\
+          cur_lock->holder->inherited_prio_size] = curT->priority;
+        cur_lock->holder->inherited_prio_size++;
+        cur_lock->holder->priority = curT->priority;
+        if (cur_lock->holder->status == THREAD_READY)
+          break;
+        curT = cur_lock->holder;
+      }
+      if (!lock->is_holder_running_with_inherited_prio)
+        lock->holder->inheritance_depth++;
+      lock->is_holder_running_with_inherited_prio = true;
+      /* re-sort the ready list as we have changed the thread priorities */
+      sort_ready_list();
+    }
+  }
   sema_down (&lock->semaphore);
   lock->holder = thread_current ();
+  lock->holder->waiting_for = NULL;
 }
 
 /* Tries to acquires LOCK and returns true if successful or false
@@ -221,6 +255,30 @@
   ASSERT (lock != NULL);
   ASSERT (lock_held_by_current_thread (lock));
 
+  struct semaphore *lock_sema=&lock->semaphore;
+  list_sort(&lock_sema->waiters, priority_comparator, NULL);
+
+  if (lock->is_holder_running_with_inherited_prio)
+  {
+    struct thread *cur = thread_current();
+    cur->inheritance_depth--;
+    if (!list_empty(&lock_sema->waiters))
+    {
+     struct thread* t1 = list_entry(list_front(&lock_sema->waiters),
+                                               struct thread, elem);
+     clear_inherited_priority(thread_current(), t1->priority);
+     thread_current()->priority = thread_current()->inherited_priorities[\
+                                 (thread_current()->inherited_prio_size)-1];
+     lock->is_holder_running_with_inherited_prio = false;
+    }
+  }
+  if(thread_current()->inheritance_depth == 0)
+  {
+    struct thread *cur = thread_current();
+    cur->inherited_prio_size = 1;
+    cur->priority = thread_current()->inherited_priorities[0];
+  }
+
   lock->holder = NULL;
   sema_up (&lock->semaphore);
 }
@@ -282,7 +340,8 @@
   ASSERT (lock_held_by_current_thread (lock));
 
   sema_init (&waiter.semaphore, 0);
-  list_push_back (&cond->waiters, &waiter.elem);
+  list_insert_ordered (&cond->waiters, &waiter.elem,
+                       priority_comparator, NULL);
   lock_release (lock);
   sema_down (&waiter.semaphore);
   lock_acquire (lock);
@@ -302,6 +361,7 @@
   ASSERT (!intr_context ());
   ASSERT (lock_held_by_current_thread (lock));
 
+  list_sort(&cond->waiters, sema_comparator, 0);
   if (!list_empty (&cond->waiters))
     sema_up (&list_entry (list_pop_front (&cond->waiters),
                           struct semaphore_elem, elem)
@@ -322,3 +382,13 @@
   while (!list_empty (&cond->waiters))
     cond_signal (cond, lock);
 }
+
+/* comapare semaphore waiters based on priority */
+bool sema_comparator(const struct list_elem *l1, const struct list_elem *l2,void *aux UNUSED)
+{
+  struct semaphore_elem *t1 = list_entry(l1,struct semaphore_elem,elem);
+  struct semaphore_elem *t2 = list_entry(l2,struct semaphore_elem,elem);
+  struct semaphore *s1=&t1->semaphore;
+  struct semaphore *s2=&t2->semaphore;
+  return priority_comparator(list_front(&s1->waiters), list_front(&s2->waiters), NULL);
+}
diff -ruN '--exclude=build' aos_pintos/src/threads/synch.h pintos-solution/src/threads/synch.h
--- aos_pintos/src/threads/synch.h	2024-02-08 21:49:22.000000000 +0000
+++ pintos-solution/src/threads/synch.h	2024-02-28 15:05:59.021536790 +0000
@@ -22,6 +22,8 @@
 {
   struct thread *holder;      /* Thread holding lock. */
   struct semaphore semaphore; /* Binary semaphore controlling access. */
+  /* Indicates if lock holder is running with donated prio */
+  bool is_holder_running_with_inherited_prio;
 };
 
 void lock_init (struct lock *);
diff -ruN '--exclude=build' aos_pintos/src/threads/thread.c pintos-solution/src/threads/thread.c
--- aos_pintos/src/threads/thread.c	2024-02-08 21:49:22.000000000 +0000
+++ pintos-solution/src/threads/thread.c	2024-02-28 18:04:13.564703696 +0000
@@ -71,6 +71,40 @@
 void thread_schedule_tail (struct thread *prev);
 static tid_t allocate_tid (void);
 
+/* return true if t1->prio > t2->prio */
+bool priority_comparator(const struct list_elem *l1, const struct list_elem *l2,void *aux UNUSED)
+{
+  struct thread *t1 = list_entry(l1,struct thread,elem);
+  struct thread *t2 = list_entry(l2,struct thread,elem);
+  if( t1->priority > t2->priority)
+    return true;
+  return false;
+}
+
+void sort_ready_list(void)
+{
+  list_sort(&ready_list, priority_comparator, 0);
+}
+
+/* search the inherited_prio list for the inherited priority
+   and remove it from the list */
+void clear_inherited_priority(struct thread *cur,int prio)
+{
+  int i, prio_found = 0;
+  for(i = 0; i < (cur->inherited_prio_size)-1; i++)
+  {
+    if(cur->inherited_priorities[i] == prio)
+    {
+      prio_found = 1;
+    }
+    if(prio_found == 1)
+    {
+      cur->inherited_priorities[i] = cur->inherited_priorities[i+1];
+    }
+  }
+  cur->inherited_prio_size--;
+}
+
 /* Initializes the threading system by transforming the code
    that's currently running into a thread.  This can't work in
    general and it is possible in this case only because loader.S
@@ -195,6 +229,7 @@
 
   /* Add to run queue. */
   thread_unblock (t);
+  thread_yield();
 
   return tid;
 }
@@ -230,7 +265,8 @@
 
   old_level = intr_disable ();
   ASSERT (t->status == THREAD_BLOCKED);
-  list_push_back (&ready_list, &t->elem);
+  list_insert_ordered (&ready_list, &t->elem,
+                       priority_comparator, NULL);
   t->status = THREAD_READY;
   intr_set_level (old_level);
 }
@@ -290,7 +326,8 @@
 
   old_level = intr_disable ();
   if (cur != idle_thread)
-    list_push_back (&ready_list, &cur->elem);
+    list_insert_ordered (&ready_list, &cur->elem,
+                         priority_comparator, NULL);
   cur->status = THREAD_READY;
   schedule ();
   intr_set_level (old_level);
@@ -314,7 +351,12 @@
 /* Sets the current thread's priority to NEW_PRIORITY. */
 void thread_set_priority (int new_priority)
 {
-  thread_current ()->priority = new_priority;
+  thread_current()->inherited_priorities[0] = new_priority;
+  if (thread_current()->inherited_prio_size == 1)
+  {
+    thread_current()->priority = new_priority;
+    thread_yield();
+  }
 }
 
 /* Returns the current thread's priority. */
@@ -427,8 +469,11 @@
   strlcpy (t->name, name, sizeof t->name);
   t->stack = (uint8_t *) t + PGSIZE;
   t->priority = priority;
+  t->inherited_priorities[0] = priority;
+  t->inherited_prio_size = 1;
+  t->inheritance_depth = 0;
   t->magic = THREAD_MAGIC;
-
+  t->waiting_for = NULL;
   old_level = intr_disable ();
   list_push_back (&all_list, &t->allelem);
   intr_set_level (old_level);
diff -ruN '--exclude=build' aos_pintos/src/threads/thread.h pintos-solution/src/threads/thread.h
--- aos_pintos/src/threads/thread.h	2024-02-08 21:49:22.000000000 +0000
+++ pintos-solution/src/threads/thread.h	2024-02-28 18:04:18.903580126 +0000
@@ -95,6 +95,14 @@
   /* Shared between thread.c and synch.c. */
   struct list_elem elem; /* List element. */
 
+  int64_t wakeup_tick;
+  struct list_elem timer_elem;
+
+  int inherited_priorities[32];
+  int inherited_prio_size;
+  int inheritance_depth;
+  struct lock *waiting_for;
+
 #ifdef USERPROG
   /* Owned by userprog/process.c. */
   uint32_t *pagedir; /* Page directory. */
@@ -139,5 +147,8 @@
 void thread_set_nice (int);
 int thread_get_recent_cpu (void);
 int thread_get_load_avg (void);
+bool priority_comparator(const struct list_elem *l1, const struct list_elem *l2, void *aux);
+void sort_ready_list(void);
+void clear_inherited_priority(struct thread *cur, int prio);
 
 #endif /* threads/thread.h */
